<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lr1110_driver: lr1110_driver/src/lr1110_wifi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lr1110_driver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_9da5e55f4b5e6279dec863e382a3e740.html">lr1110_driver</a></li><li class="navelem"><a class="el" href="dir_3c71178d898afd3b302f88dd953c48b8.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lr1110_wifi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wi-Fi passive scan driver definition for LR1110.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="lr1110__regmem_8h_source.html">lr1110_regmem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lr1110__wifi__types_8h_source.html">lr1110_wifi_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lr1110__types_8h_source.html">lr1110_types.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for lr1110_wifi.h:</div>
<div class="dyncontent">
<div class="center"><img src="lr1110__wifi_8h__incl.png" border="0" usemap="#alr1110__driver_2src_2lr1110__wifi_8h" alt=""/></div>
<map name="lr1110__driver_2src_2lr1110__wifi_8h" id="alr1110__driver_2src_2lr1110__wifi_8h">
<area shape="rect" title="Wi&#45;Fi passive scan driver definition for LR1110." alt="" coords="70,5,246,47"/>
<area shape="rect" href="lr1110__regmem_8h.html" title="Register/memory driver definition for LR1110." alt="" coords="89,95,227,121"/>
<area shape="rect" href="lr1110__types_8h.html" title="Type definitions for LR1110." alt="" coords="5,169,124,196"/>
<area shape="rect" href="lr1110__wifi__types_8h.html" title="Wi&#45;Fi passive scan driver types for LR1110." alt="" coords="251,95,399,121"/>
<area shape="rect" title=" " alt="" coords="175,169,245,196"/>
<area shape="rect" title=" " alt="" coords="283,169,366,196"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="lr1110__wifi_8h__dep__incl.png" border="0" usemap="#alr1110__driver_2src_2lr1110__wifi_8hdep" alt=""/></div>
<map name="lr1110__driver_2src_2lr1110__wifi_8hdep" id="alr1110__driver_2src_2lr1110__wifi_8hdep">
<area shape="rect" title="Wi&#45;Fi passive scan driver definition for LR1110." alt="" coords="5,5,181,47"/>
<area shape="rect" href="lr1110__wifi_8c.html" title="Wi&#45;Fi passive scan driver implementation for LR1110." alt="" coords="5,95,181,136"/>
</map>
</div>
</div>
<p><a href="lr1110__wifi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ada49120c783c278ea384029687de12d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#ada49120c783c278ea384029687de12d0">LR1110_WIFI_N_RESULTS_MAX_PER_CHUNK</a>&#160;&#160;&#160;LR1110_WIFI_MAX_RESULTS</td></tr>
<tr class="memdesc:ada49120c783c278ea384029687de12d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of results max to fetch per SPI communication with the chip.  <a href="lr1110__wifi_8h.html#ada49120c783c278ea384029687de12d0">More...</a><br /></td></tr>
<tr class="separator:ada49120c783c278ea384029687de12d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a403db776bcaf46d2964f1621e1f1ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a8a403db776bcaf46d2964f1621e1f1ca">lr1110_wifi_scan</a> (const void *context, const <a class="el" href="lr1110__wifi__types_8h.html#ad508a09a7b89a18ffe23365d4eacc4e0">lr1110_wifi_signal_type_scan_t</a> signal_type, const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a> channels, const <a class="el" href="lr1110__wifi__types_8h.html#a8ebe30600fcea1efe826ea614d472280">lr1110_wifi_mode_t</a> scan_mode, const uint8_t max_results, const uint8_t nb_scan_per_channel, const uint16_t timeout_in_ms, const bool abort_on_timeout)</td></tr>
<tr class="memdesc:a8a403db776bcaf46d2964f1621e1f1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Wi-Fi passive scan operation.  <a href="lr1110__wifi_8h.html#a8a403db776bcaf46d2964f1621e1f1ca">More...</a><br /></td></tr>
<tr class="separator:a8a403db776bcaf46d2964f1621e1f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a86b1bca06ce60e05f30c549e4aa004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a3a86b1bca06ce60e05f30c549e4aa004">lr1110_wifi_search_country_code</a> (const void *context, const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a> channels_mask, const uint8_t nb_max_results, const uint8_t nb_scan_per_channel, const uint16_t timeout_in_ms, const bool abort_on_timeout)</td></tr>
<tr class="memdesc:a3a86b1bca06ce60e05f30c549e4aa004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Wi-Fi passive scan for country codes extraction.  <a href="lr1110__wifi_8h.html#a3a86b1bca06ce60e05f30c549e4aa004">More...</a><br /></td></tr>
<tr class="separator:a3a86b1bca06ce60e05f30c549e4aa004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cdc2ec9e6d72e30fb83c1567f54d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#aa1cdc2ec9e6d72e30fb83c1567f54d31">lr1110_wifi_scan_time_limit</a> (const void *context, const <a class="el" href="lr1110__wifi__types_8h.html#ad508a09a7b89a18ffe23365d4eacc4e0">lr1110_wifi_signal_type_scan_t</a> signal_type, const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a> channels, const <a class="el" href="lr1110__wifi__types_8h.html#a8ebe30600fcea1efe826ea614d472280">lr1110_wifi_mode_t</a> scan_mode, const uint8_t max_results, const uint16_t timeout_per_channel_ms, const uint16_t timeout_per_scan_ms)</td></tr>
<tr class="memdesc:aa1cdc2ec9e6d72e30fb83c1567f54d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Wi-Fi passive scan operation with duration stop conditions.  <a href="lr1110__wifi_8h.html#aa1cdc2ec9e6d72e30fb83c1567f54d31">More...</a><br /></td></tr>
<tr class="separator:aa1cdc2ec9e6d72e30fb83c1567f54d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9f61cf1b5be312b898e265425c936e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a7b9f61cf1b5be312b898e265425c936e">lr1110_wifi_search_country_code_time_limit</a> (const void *context, const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a> channels_mask, const uint8_t nb_max_results, const uint16_t timeout_per_channel_ms, const uint16_t timeout_per_scan_ms)</td></tr>
<tr class="memdesc:a7b9f61cf1b5be312b898e265425c936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Wi-Fi passive scan for country codes extraction with duration stop conditions.  <a href="lr1110__wifi_8h.html#a7b9f61cf1b5be312b898e265425c936e">More...</a><br /></td></tr>
<tr class="separator:a7b9f61cf1b5be312b898e265425c936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceacb572995705d93d049e1f6e058f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a> (const void *context, uint8_t *nb_results)</td></tr>
<tr class="memdesc:aceacb572995705d93d049e1f6e058f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of results currently available in LR1110.  <a href="lr1110__wifi_8h.html#aceacb572995705d93d049e1f6e058f0e">More...</a><br /></td></tr>
<tr class="separator:aceacb572995705d93d049e1f6e058f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa8b1b61c77ebfade5287f79cb0fb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#afaa8b1b61c77ebfade5287f79cb0fb4c">lr1110_wifi_read_basic_complete_results</a> (const void *context, const uint8_t start_result_index, const uint8_t nb_results, <a class="el" href="lr1110__wifi__types_8h.html#afe5b51fb4e75966e87334d26a69f6644">lr1110_wifi_basic_complete_result_t</a> *results)</td></tr>
<tr class="memdesc:afaa8b1b61c77ebfade5287f79cb0fb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read basic complete results.  <a href="lr1110__wifi_8h.html#afaa8b1b61c77ebfade5287f79cb0fb4c">More...</a><br /></td></tr>
<tr class="separator:afaa8b1b61c77ebfade5287f79cb0fb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3549195b4839a4ba91ea6cbfd15ae64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#af3549195b4839a4ba91ea6cbfd15ae64">lr1110_wifi_read_basic_mac_type_channel_results</a> (const void *context, const uint8_t start_result_index, const uint8_t nb_results, <a class="el" href="lr1110__wifi__types_8h.html#afef29b7cead307769ae4d3667829f7aa">lr1110_wifi_basic_mac_type_channel_result_t</a> *results)</td></tr>
<tr class="memdesc:af3549195b4839a4ba91ea6cbfd15ae64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read basic MAC, Wi-Fi type and channel results.  <a href="lr1110__wifi_8h.html#af3549195b4839a4ba91ea6cbfd15ae64">More...</a><br /></td></tr>
<tr class="separator:af3549195b4839a4ba91ea6cbfd15ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b8b6b2947c8a26554cffc9b26c6369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a81b8b6b2947c8a26554cffc9b26c6369">lr1110_wifi_read_extended_full_results</a> (const void *radio, const uint8_t start_result_index, const uint8_t nb_results, <a class="el" href="structlr1110__wifi__extended__full__result__t.html">lr1110_wifi_extended_full_result_t</a> *results)</td></tr>
<tr class="memdesc:a81b8b6b2947c8a26554cffc9b26c6369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read extended complete results.  <a href="lr1110__wifi_8h.html#a81b8b6b2947c8a26554cffc9b26c6369">More...</a><br /></td></tr>
<tr class="separator:a81b8b6b2947c8a26554cffc9b26c6369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ceb1521a3c898827517435b621c2a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#ab8ceb1521a3c898827517435b621c2a7">lr1110_wifi_reset_cumulative_timing</a> (const void *context)</td></tr>
<tr class="memdesc:ab8ceb1521a3c898827517435b621c2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal counters of cumulative timing.  <a href="lr1110__wifi_8h.html#ab8ceb1521a3c898827517435b621c2a7">More...</a><br /></td></tr>
<tr class="separator:ab8ceb1521a3c898827517435b621c2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7941b72b58a2dae76fecbe3246cb07c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a7941b72b58a2dae76fecbe3246cb07c4">lr1110_wifi_read_cumulative_timing</a> (const void *context, <a class="el" href="lr1110__wifi__types_8h.html#a1cf72df541b0429ac38c286e59077dd5">lr1110_wifi_cumulative_timings_t</a> *timing)</td></tr>
<tr class="memdesc:a7941b72b58a2dae76fecbe3246cb07c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the internal counters of cumulative timing.  <a href="lr1110__wifi_8h.html#a7941b72b58a2dae76fecbe3246cb07c4">More...</a><br /></td></tr>
<tr class="separator:a7941b72b58a2dae76fecbe3246cb07c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed08daaa085ca5ee6fccac5e559d99f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#aed08daaa085ca5ee6fccac5e559d99f5">lr1110_wifi_get_nb_country_code_results</a> (const void *context, uint8_t *nb_country_code_results)</td></tr>
<tr class="memdesc:aed08daaa085ca5ee6fccac5e559d99f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of country code search results.  <a href="lr1110__wifi_8h.html#aed08daaa085ca5ee6fccac5e559d99f5">More...</a><br /></td></tr>
<tr class="separator:aed08daaa085ca5ee6fccac5e559d99f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfcca113b09db1f26d6180ab0baf06b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a4cfcca113b09db1f26d6180ab0baf06b">lr1110_wifi_read_country_code_results</a> (const void *context, const uint8_t start_result_index, const uint8_t nb_country_results, <a class="el" href="lr1110__wifi__types_8h.html#ac2d739e442552f15bf6ebd121894ae6a">lr1110_wifi_country_code_t</a> *country_code_results)</td></tr>
<tr class="memdesc:a4cfcca113b09db1f26d6180ab0baf06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read country code results.  <a href="lr1110__wifi_8h.html#a4cfcca113b09db1f26d6180ab0baf06b">More...</a><br /></td></tr>
<tr class="separator:a4cfcca113b09db1f26d6180ab0baf06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830785641ca030a7ea55093bff70605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a0830785641ca030a7ea55093bff70605">lr1110_wifi_cfg_timestamp_ap_phone</a> (const void *context, uint32_t timestamp_in_s)</td></tr>
<tr class="memdesc:a0830785641ca030a7ea55093bff70605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the timestamp used to discriminate mobile access points from gateways.  <a href="lr1110__wifi_8h.html#a0830785641ca030a7ea55093bff70605">More...</a><br /></td></tr>
<tr class="separator:a0830785641ca030a7ea55093bff70605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7521fc045807639176f8a329116bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a1a7521fc045807639176f8a329116bb4">lr1110_wifi_read_version</a> (const void *context, <a class="el" href="lr1110__wifi__types_8h.html#acc25030e0dfd97c4eb3280a80713d69c">lr1110_wifi_version_t</a> *wifi_version)</td></tr>
<tr class="memdesc:a1a7521fc045807639176f8a329116bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal wifi firmware version.  <a href="lr1110__wifi_8h.html#a1a7521fc045807639176f8a329116bb4">More...</a><br /></td></tr>
<tr class="separator:a1a7521fc045807639176f8a329116bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad276a2e5ad038fd6eadfe99211f60040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#ad276a2e5ad038fd6eadfe99211f60040">lr1110_wifi_parse_channel_info</a> (const <a class="el" href="lr1110__wifi__types_8h.html#a55e3c183efeb5aa35eadfff058f3f5e1">lr1110_wifi_channel_info_byte_t</a> channel_info, <a class="el" href="lr1110__wifi__types_8h.html#a17c9dcc3e3e493f2a6ef4d877694955e">lr1110_wifi_channel_t</a> *channel, bool *rssi_validity, <a class="el" href="lr1110__wifi__types_8h.html#a52372df6137d900b25c37f6ba2707dbe">lr1110_wifi_mac_origin_t</a> *mac_origin_estimation)</td></tr>
<tr class="memdesc:ad276a2e5ad038fd6eadfe99211f60040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retreive channel information from channel info byte.  <a href="lr1110__wifi_8h.html#ad276a2e5ad038fd6eadfe99211f60040">More...</a><br /></td></tr>
<tr class="separator:ad276a2e5ad038fd6eadfe99211f60040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240bebced5794ce6dd84c017b287d56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__wifi__types_8h.html#a17c9dcc3e3e493f2a6ef4d877694955e">lr1110_wifi_channel_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a240bebced5794ce6dd84c017b287d56e">lr1110_wifi_extract_channel_from_info_byte</a> (const <a class="el" href="lr1110__wifi__types_8h.html#a55e3c183efeb5aa35eadfff058f3f5e1">lr1110_wifi_channel_info_byte_t</a> channel_info)</td></tr>
<tr class="memdesc:a240bebced5794ce6dd84c017b287d56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to retrieve channel from channel info byte.  <a href="lr1110__wifi_8h.html#a240bebced5794ce6dd84c017b287d56e">More...</a><br /></td></tr>
<tr class="separator:a240bebced5794ce6dd84c017b287d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe1fb53c0befea5ab7b46cfa22ad9bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a0fe1fb53c0befea5ab7b46cfa22ad9bb">lr1110_wifi_parse_frame_type_info</a> (const <a class="el" href="lr1110__wifi__types_8h.html#ac77a5ef55c00bf569d351b1f15c5751a">lr1110_wifi_frame_type_info_byte_t</a> frame_type_info, <a class="el" href="lr1110__wifi__types_8h.html#ae25235b3295d30fb4ff8919621d9d2c1">lr1110_wifi_frame_type_t</a> *frame_type, <a class="el" href="lr1110__wifi__types_8h.html#ade9a701f69fbd51944d656ff077d9a31">lr1110_wifi_frame_sub_type_t</a> *frame_sub_type, bool *to_ds, bool *from_ds)</td></tr>
<tr class="memdesc:a0fe1fb53c0befea5ab7b46cfa22ad9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the Frame Type, Frame Subtype, To/From DS fields from a frame info byte.  <a href="lr1110__wifi_8h.html#a0fe1fb53c0befea5ab7b46cfa22ad9bb">More...</a><br /></td></tr>
<tr class="separator:a0fe1fb53c0befea5ab7b46cfa22ad9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ea70c760033e0dd8d89706961d6ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#aa4ea70c760033e0dd8d89706961d6ef5">lr1110_wifi_parse_data_rate_info</a> (const <a class="el" href="lr1110__wifi__types_8h.html#a82d577debca5410696b4f512da982462">lr1110_wifi_datarate_info_byte_t</a> data_rate_info, <a class="el" href="lr1110__wifi__types_8h.html#a14d9ec9ba9116e22b5da4f8af7d1d9a5">lr1110_wifi_signal_type_result_t</a> *wifi_signal_type, <a class="el" href="lr1110__wifi__types_8h.html#a3a34adce775e61290a566006f51d6801">lr1110_wifi_datarate_t</a> *wifi_data_rate)</td></tr>
<tr class="memdesc:aa4ea70c760033e0dd8d89706961d6ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the data rate information from data rate info byte.  <a href="lr1110__wifi_8h.html#aa4ea70c760033e0dd8d89706961d6ef5">More...</a><br /></td></tr>
<tr class="separator:aa4ea70c760033e0dd8d89706961d6ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe6dae23951bad6722ca4fe3cd9317a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#abfe6dae23951bad6722ca4fe3cd9317a">lr1110_wifi_get_nb_results_max_per_chunk</a> (void)</td></tr>
<tr class="memdesc:abfe6dae23951bad6722ca4fe3cd9317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximal number of results to read per SPI communication.  <a href="lr1110__wifi_8h.html#abfe6dae23951bad6722ca4fe3cd9317a">More...</a><br /></td></tr>
<tr class="separator:abfe6dae23951bad6722ca4fe3cd9317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4621fe36d6aefdcb5bd80c8de55dbc1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="lr1110__wifi__types_8h.html#a14d9ec9ba9116e22b5da4f8af7d1d9a5">lr1110_wifi_signal_type_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#a4621fe36d6aefdcb5bd80c8de55dbc1c">lr1110_wifi_extract_signal_type_from_data_rate_info</a> (const <a class="el" href="lr1110__wifi__types_8h.html#a82d577debca5410696b4f512da982462">lr1110_wifi_datarate_info_byte_t</a> data_rate_info)</td></tr>
<tr class="memdesc:a4621fe36d6aefdcb5bd80c8de55dbc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to retrieve the signal type from data rate info byte.  <a href="lr1110__wifi_8h.html#a4621fe36d6aefdcb5bd80c8de55dbc1c">More...</a><br /></td></tr>
<tr class="separator:a4621fe36d6aefdcb5bd80c8de55dbc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c7589b9d44acd564cb14919f55ca1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lr1110__wifi_8h.html#ae9c7589b9d44acd564cb14919f55ca1c">lr1110_wifi_is_well_formed_utf8_byte_sequence</a> (const uint8_t *buffer, const uint8_t length)</td></tr>
<tr class="memdesc:ae9c7589b9d44acd564cb14919f55ca1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check if a buffer is a well-formed UTF-8 byte sequence.  <a href="lr1110__wifi_8h.html#ae9c7589b9d44acd564cb14919f55ca1c">More...</a><br /></td></tr>
<tr class="separator:ae9c7589b9d44acd564cb14919f55ca1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wi-Fi passive scan driver definition for LR1110. </p>
<p>The Clear BSD License Copyright Semtech Corporation 2021. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted (subject to the limitations in the disclaimer below) provided that the following conditions are met:</p><ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the Semtech corporation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
<p>NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SEMTECH CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ada49120c783c278ea384029687de12d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada49120c783c278ea384029687de12d0">&#9670;&nbsp;</a></span>LR1110_WIFI_N_RESULTS_MAX_PER_CHUNK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LR1110_WIFI_N_RESULTS_MAX_PER_CHUNK&#160;&#160;&#160;LR1110_WIFI_MAX_RESULTS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of results max to fetch per SPI communication with the chip. </p>
<p>This macro is used by the internals of the driver to size the internal buffers of the driver used in the <em>read results</em> functions.</p>
<p>It can be defined externally at compile time, or just before including this file.</p>
<p>Its value can be programmatically obtained at runtime by calling <a class="el" href="lr1110__wifi_8h.html#abfe6dae23951bad6722ca4fe3cd9317a" title="Return the maximal number of results to read per SPI communication.">lr1110_wifi_get_nb_results_max_per_chunk()</a> function.</p>
<p>Its default value is set to the maximum number of results saved by LR1110 chip.</p>
<dl class="section warning"><dt>Warning</dt><dd>Its value must be in the range [1,32] (inclusive). Defining out of this range leads to undefined behavior. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8a403db776bcaf46d2964f1621e1f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a403db776bcaf46d2964f1621e1f1ca">&#9670;&nbsp;</a></span>lr1110_wifi_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_scan </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ad508a09a7b89a18ffe23365d4eacc4e0">lr1110_wifi_signal_type_scan_t</a>&#160;</td>
          <td class="paramname"><em>signal_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a8ebe30600fcea1efe826ea614d472280">lr1110_wifi_mode_t</a>&#160;</td>
          <td class="paramname"><em>scan_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>max_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_scan_per_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_in_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abort_on_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a Wi-Fi passive scan operation. </p>
<p>During the complete passive scan operation, the LR1110 remains busy and cannot receive any commands. Using this command <b>DOES</b> reset the results already obtained by previous passive scan operations.</p>
<p>The result can be read at the end of the passive scan issuing the command lr1110_wifi_get_nb_results (to get the number of results to read) and lr1110_wifi_read_basic_complete_results or lr1110_wifi_read_basic_mac_type_channel_results to actually get the result bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal_type</td><td>The type of Wi-Fi Signals to scan for. If LR1110_WIFI_TYPE_SCAN_B_G_N is selected, the LR1110 already starts by scanning all selected channels for Wi-Fi signals B. Then the LR1110 scans all selected channels for Wi-Fi signals G/N. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td>Mask of the Wi-Fi channels to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_mode</td><td>Scan mode to execute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_results</td><td>The maximal number of results to gather. When this limit is reached, the passive scan automatically stop. Range of allowed values is [1:32]. Note that value 0 is forbidden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_scan_per_channel</td><td>The number of internal scan sequences per channel scanned. Range of accepted values is [1:255]. Note that value 0 is forbidden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_in_ms</td><td>The maximal duration of a single preamble search. Expressed in ms. Range of allowed values is [1:65535]. Note that value 0 is forbidden. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abort_on_timeout</td><td>If true, the beacon search jumps to next configured Wi-Fi channel (or stop if there is no more channel to scan) as soon as a search timeout is encountered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#afaa8b1b61c77ebfade5287f79cb0fb4c" title="Read basic complete results.">lr1110_wifi_read_basic_complete_results</a>, <a class="el" href="lr1110__wifi_8h.html#af3549195b4839a4ba91ea6cbfd15ae64" title="Read basic MAC, Wi-Fi type and channel results.">lr1110_wifi_read_basic_mac_type_channel_results</a> </dd></dl>

</div>
</div>
<a id="a3a86b1bca06ce60e05f30c549e4aa004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a86b1bca06ce60e05f30c549e4aa004">&#9670;&nbsp;</a></span>lr1110_wifi_search_country_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_search_country_code </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a>&#160;</td>
          <td class="paramname"><em>channels_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_max_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_scan_per_channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_in_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abort_on_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a Wi-Fi passive scan for country codes extraction. </p>
<p>This command starts a Wi-Fi passive scan operation for Beacons and Probe Responses on Wi-Fi type B only. It is to be used to extract the Country Code fields.</p>
<p>During the passive scan, the results are filtered to keep only single MAC addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels_mask</td><td>Mask of the Wi-Fi channels to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_max_results</td><td>The maximum number of country code to gather. When this limit is reached, the passive scan automatically stops. Maximal value is 32 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_scan_per_channel</td><td>Maximal number of scan attempts per channel. Maximal value is 255 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_in_ms</td><td>The maximal duration of a single beacon search. Expressed in ms. Maximal value is 65535 ms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">abort_on_timeout</td><td>If true, the beacon search jumps to next configured Wi-Fi channel (or stop if there is no more channel to scan) as soon as a search timeout is encountered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="aa1cdc2ec9e6d72e30fb83c1567f54d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cdc2ec9e6d72e30fb83c1567f54d31">&#9670;&nbsp;</a></span>lr1110_wifi_scan_time_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_scan_time_limit </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ad508a09a7b89a18ffe23365d4eacc4e0">lr1110_wifi_signal_type_scan_t</a>&#160;</td>
          <td class="paramname"><em>signal_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a8ebe30600fcea1efe826ea614d472280">lr1110_wifi_mode_t</a>&#160;</td>
          <td class="paramname"><em>scan_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>max_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_per_channel_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_per_scan_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a Wi-Fi passive scan operation with duration stop conditions. </p>
<p>This passive scan API does not require the number of scan per channel, so that it searches for Wi-Fi signals until it finds one, or until the exhaustion of timeout_per_scan_ms or timeout_per_channel_ms.</p>
<p>The maximal duration of a scan is determined by the number of channels to scan times the timeout_per_channel_ms configured. However, this duration may be exceeded depending on the crystal drift of the clock source and on the instant the last Wi-Fi signal is detected by the device. Therefore the maximal duration of a Wi-Fi scan with this API is provided by the following equations:</p>
<p>For signal type being <code>LR1110_WIFI_TYPE_SCAN_B</code>, <code>LR1110_WIFI_TYPE_SCAN_G</code> or <code>LR1110_WIFI_TYPE_SCAN_N</code>:</p>
<p><img class="formulaInl" alt="$ T_{max} = N_{channel} \times ((1 + Xtal_{precision})timeout\_per\_channel + T_{offset} ) $" src="form_14.png" width="383" height="14"/></p>
<p><img class="formulaInl" alt="$ Xtal_{precision} $" src="form_15.png" width="69" height="14"/> depends on the crystal used as clock source. If the clock source is configured with 32kHz internal RC, then <img class="formulaInl" alt="$ Xtal_{precision} = 1/100 $" src="form_16.png" width="118" height="14"/></p>
<p><img class="formulaInl" alt="$ T_{offset} $" src="form_17.png" width="38" height="13"/> depends on the <img class="formulaInl" alt="$ signal\_type $" src="form_18.png" width="63" height="13"/> and the <img class="formulaInl" alt="$scan\_mode$" src="form_19.png" width="59" height="10"/> selected:</p>
<ul>
<li>LR1110_WIFI_TYPE_SCAN_B:<ul>
<li>if <img class="formulaInl" alt="$scan\_mode != LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_20.png" width="360" height="10"/>: 2.31 ms</li>
<li>if <img class="formulaInl" alt="$scan\_mode == LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_21.png" width="366" height="10"/>: 9.59 ms</li>
</ul>
</li>
<li>LR1110_WIFI_TYPE_SCAN_G:<ul>
<li>if <img class="formulaInl" alt="$scan\_mode != LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_20.png" width="360" height="10"/>: 52.55 ms</li>
<li>if <img class="formulaInl" alt="$scan\_mode == LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_21.png" width="366" height="10"/>: N/A</li>
</ul>
</li>
</ul>
<p>For signal type being <code>LR1110_WIFI_TYPE_SCAN_B_G_N</code>:</p>
<p><img class="formulaInl" alt="$ T_{max} = 2 \times N_{channel} \times (1 + Xtal_{precision})timeout\_per\_channel + T_{offset} $" src="form_22.png" width="395" height="14"/></p>
<p><img class="formulaInl" alt="$ T_{offset} $" src="form_17.png" width="38" height="13"/> depends on the <img class="formulaInl" alt="$scan\_mode$" src="form_19.png" width="59" height="10"/> selected:</p><ul>
<li><img class="formulaInl" alt="$scan\_mode != LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_20.png" width="360" height="10"/>: 54.86 ms</li>
<li><img class="formulaInl" alt="$scan\_mode == LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_21.png" width="366" height="10"/>: 9.59 ms.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>With <img class="formulaInl" alt="$scan\_mode != LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_20.png" width="360" height="10"/> the T_offset is actually the worst case of Wi-Fi type B and Wi-Fi type G/N. Moreover, the Wi-Fi types G and N are scanned within the same steps (it is not two different scans). So the T_offset is the addition of 2.31 + 52.55 = 54.86.</dd>
<dd>
With <img class="formulaInl" alt="$scan\_mode == LR1110\_WIFI\_SCAN\_MODE\_FULL\_BEACON$" src="form_21.png" width="366" height="10"/>, only Wi-Fi types B can be scanned. So scans for Wi-Fi types G/N are silently discarded. Therefore the T_offset is the same as for scan with Wi-Fi type B.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signal_type</td><td>The type of Wi-Fi Signals to scan for. If LR1110_WIFI_TYPE_SCAN_B_G_N is selected, the LR1110 already starts by scanning all selected channels for Wi-Fi signals B. Then the LR1110 scans all selected channels for Wi-Fi signals G/N. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels</td><td>Mask of the Wi-Fi channels to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_mode</td><td>Scan mode to execute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_results</td><td>The maximal number of results to gather. When this limit is reached, the passive scan automatically stop. Maximal value is 32 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_per_channel_ms</td><td>The time to spend scanning one channel. Expressed in ms. Value 0 is forbidden and will result in the raise of WIFI_SCAN_DONE interrupt, with stat1.command_status being set to LR1110_SYSTEM_CMD_STATUS_PERR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_per_scan_ms</td><td>The maximal time to spend in preamble detection for each single scan. The time spent on preamble search is reset at each new preamble search. If the time spent on preamble search reach this timeout, the scan on the current channel stops and start on next channel. If set to 0, the command will keep listening until exhaustion of timeout_per_channel_ms or until nb_max_results is reached. Expressed in ms. Range of allowed values is [0:65535].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<dl class="section see"><dt>See also</dt><dd>lr1110_wifi_read_basic_results, lr1110_wifi_read_extended_results </dd></dl>

</div>
</div>
<a id="a7b9f61cf1b5be312b898e265425c936e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9f61cf1b5be312b898e265425c936e">&#9670;&nbsp;</a></span>lr1110_wifi_search_country_code_time_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_search_country_code_time_limit </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ab203821a76aae078185f3baa26104b3d">lr1110_wifi_channel_mask_t</a>&#160;</td>
          <td class="paramname"><em>channels_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_max_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_per_channel_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>timeout_per_scan_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a Wi-Fi passive scan for country codes extraction with duration stop conditions. </p>
<p>This command starts a Wi-Fi passive scan operation for Beacons and Probe Responses on Wi-Fi type B only. It is to be used to extract the Country Code fields. This passive scan API does not require the number of scan per channel, so that it searches for Wi-Fi signals until it finds one, or until the exhaustion of timeout_per_scan_ms or timeout_per_channel_ms.</p>
<p>The maximal duration of a scan is determined by the number of channels to scan times the timeout_per_channel_ms configured. However, this duration may be exceeded depending on the crystal drift of the clock source and on the instant the last Wi-Fi signal is detected by the device. Therefore the maximal duration of a Wi-Fi scan with this API is provided by the following equation:</p>
<p><img class="formulaInl" alt="$ T_{max} = N_{channel} \times ((1 + Xtal_{precision})timeout\_per\_channel + T_{offset} ) $" src="form_14.png" width="383" height="14"/></p>
<p><img class="formulaInl" alt="$ Xtal_{precision} $" src="form_15.png" width="69" height="14"/> depends on the crystal used as clock source. If the clock source is configured with 32kHz internal RC, then <img class="formulaInl" alt="$ Xtal_{precision} = 1/100 $" src="form_16.png" width="118" height="14"/></p>
<p><img class="formulaInl" alt="$ T_{offset} $" src="form_17.png" width="38" height="13"/> is always the same: 9.59 ms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channels_mask</td><td>Mask of the Wi-Fi channels to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_max_results</td><td>The maximum number of country code to gather. When this limit is reached, the passive scan automatically stops. Maximal value is 32 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_per_channel_ms</td><td>The time to spend scanning one channel. Expressed in ms. Value 0 is forbidden and will result in the raise of WIFI_SCAN_DONE interrupt, with stat1.command_status being set to LR1110_SYSTEM_CMD_STATUS_PERR </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_per_scan_ms</td><td>The maximal time to spend in preamble detection for each single scan. The time spent on preamble search is reset at each new preamble search. If the time spent on preamble search reach this timeout, the scan on the current channel stops and start on next channel. If set to 0, the command will keep listening until exhaustion of timeout_per_channel_ms or until nb_max_results is reached. Expressed in ms. Range of allowed values is [0:65535].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="aceacb572995705d93d049e1f6e058f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceacb572995705d93d049e1f6e058f0e">&#9670;&nbsp;</a></span>lr1110_wifi_get_nb_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_get_nb_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>nb_results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of results currently available in LR1110. </p>
<p>It can be called before lr1110_wifi_read_basic_complete_results or lr1110_wifi_read_basic_mac_type_channel_results to know the number of results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_results</td><td>The number of results available in the LR1110</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#afaa8b1b61c77ebfade5287f79cb0fb4c" title="Read basic complete results.">lr1110_wifi_read_basic_complete_results</a>, <a class="el" href="lr1110__wifi_8h.html#af3549195b4839a4ba91ea6cbfd15ae64" title="Read basic MAC, Wi-Fi type and channel results.">lr1110_wifi_read_basic_mac_type_channel_results</a> </dd></dl>

</div>
</div>
<a id="afaa8b1b61c77ebfade5287f79cb0fb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa8b1b61c77ebfade5287f79cb0fb4c">&#9670;&nbsp;</a></span>lr1110_wifi_read_basic_complete_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_basic_complete_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>start_result_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#afe5b51fb4e75966e87334d26a69f6644">lr1110_wifi_basic_complete_result_t</a> *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read basic complete results. </p>
<p>This function can be used to fetch all results in a row, or one after the other.</p>
<p>An example of usage to fetch all results in a row is: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__basic__complete__result__s.html">lr1110_wifi_basic_complete_result_t</a> all_results[LR1110_WIFI_MAX_RESULTS] = {0};</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#afaa8b1b61c77ebfade5287f79cb0fb4c">lr1110_wifi_read_basic_complete_results</a>(&amp;radio, 0, nb_results, all_results);</div>
</div><!-- fragment --><p>On the other hand, fetching result one after the other: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__basic__complete__result__s.html">lr1110_wifi_basic_complete_result_t</a> single_results = {0};</div>
<div class="line"><span class="keywordflow">for</span>(uint8_t index_result = 0; index_result &lt; nb_results; index_result++){</div>
<div class="line">  <a class="code" href="lr1110__wifi_8c.html#afaa8b1b61c77ebfade5287f79cb0fb4c">lr1110_wifi_read_basic_complete_results</a>(&amp;radio, index_result, 1, &amp;single_results);</div>
<div class="line">  <span class="comment">// Do something with single_results</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>: This result fetching function <b>MUST</b> be used only if the scan function call was made with Scan Mode set to LR1110_WIFI_SCAN_MODE_BEACON or LR1110_WIFI_SCAN_MODE_BEACON_AND_PKT.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radio</td><td>Radio abstraction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_result_index</td><td>Result index from which starting to fetch the results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_results</td><td>Number of results to fetch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>Pointer to an array of result structures to populate. It is up to the caller to ensure this array can hold at least nb_results elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<p>/see lr1110_wifi_read_basic_mac_type_channel_results, lr1110_wifi_read_extended_full_results </p>

</div>
</div>
<a id="af3549195b4839a4ba91ea6cbfd15ae64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3549195b4839a4ba91ea6cbfd15ae64">&#9670;&nbsp;</a></span>lr1110_wifi_read_basic_mac_type_channel_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_basic_mac_type_channel_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>start_result_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#afef29b7cead307769ae4d3667829f7aa">lr1110_wifi_basic_mac_type_channel_result_t</a> *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read basic MAC, Wi-Fi type and channel results. </p>
<p>This function can be used to fetch all results in a row, or one after the other.</p>
<p>An example of usage to fetch all results in a row is: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__basic__mac__type__channel__result__s.html">lr1110_wifi_basic_mac_type_channel_result_t</a> all_results[LR1110_WIFI_MAX_RESULTS] = {0};</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#af3549195b4839a4ba91ea6cbfd15ae64">lr1110_wifi_read_basic_mac_type_channel_results</a>(&amp;radio, 0, nb_results, all_results);</div>
</div><!-- fragment --><p>On the other hand, fetching result one after the other: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__basic__mac__type__channel__result__s.html">lr1110_wifi_basic_mac_type_channel_result_t</a> single_results = {0};</div>
<div class="line"><span class="keywordflow">for</span>(uint8_t index_result = 0; index_result &lt; nb_results; index_result++){</div>
<div class="line">  <a class="code" href="lr1110__wifi_8c.html#af3549195b4839a4ba91ea6cbfd15ae64">lr1110_wifi_read_basic_mac_type_channel_results</a>(&amp;radio, index_result, 1, &amp;single_results);</div>
<div class="line">  <span class="comment">// Do something with single_results</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>: This result fetching function <b>MUST</b> be used only if the scan function call was made with Scan Mode set to LR1110_WIFI_SCAN_MODE_BEACON or LR1110_WIFI_SCAN_MODE_BEACON_AND_PKT.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radio</td><td>Radio abstraction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_result_index</td><td>Result index from which starting to fetch the results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_results</td><td>Number of results to fetch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>Pointer to an array of result structures to populate. It is up to the caller to ensure this array can hold at least nb_results elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<p>/see lr1110_wifi_read_basic_complete_results, lr1110_wifi_read_extended_full_results </p>

</div>
</div>
<a id="a81b8b6b2947c8a26554cffc9b26c6369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b8b6b2947c8a26554cffc9b26c6369">&#9670;&nbsp;</a></span>lr1110_wifi_read_extended_full_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_extended_full_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>radio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>start_result_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlr1110__wifi__extended__full__result__t.html">lr1110_wifi_extended_full_result_t</a> *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read extended complete results. </p>
<p>This function can be used to fetch all results in a row, or one after the other.</p>
<p>An example of usage to fetch all results in a row is: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__extended__full__result__t.html">lr1110_wifi_extended_full_result_t</a> all_results[LR1110_WIFI_MAX_RESULTS] = {0};</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#a81b8b6b2947c8a26554cffc9b26c6369">lr1110_wifi_read_extended_full_results</a>(&amp;radio, 0, nb_results, all_results);</div>
</div><!-- fragment --><p>On the other hand, fetching result one after the other: </p><div class="fragment"><div class="line">uint8_t nb_results = 0;</div>
<div class="line"><a class="code" href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a>(&amp;radio, &amp;nb_results);</div>
<div class="line"><a class="code" href="structlr1110__wifi__extended__full__result__t.html">lr1110_wifi_extended_full_result_t</a> single_results = {0};</div>
<div class="line"><span class="keywordflow">for</span>(uint8_t index_result = 0; index_result &lt; nb_results; index_result++){</div>
<div class="line">  <a class="code" href="lr1110__wifi_8c.html#a81b8b6b2947c8a26554cffc9b26c6369">lr1110_wifi_read_extended_full_results</a>(&amp;radio, index_result, 1, &amp;single_results);</div>
<div class="line">  <span class="comment">// Do something with single_results</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>: This result fetching function <b>MUST</b> be used only if the scan function call was made with Scan Mode set to LR1110_WIFI_SCAN_MODE_FULL_BEACON.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">radio</td><td>Radio abstraction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_result_index</td><td>Result index from which starting to fetch the results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_results</td><td>Number of results to fetch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">results</td><td>Pointer to an array of result structures to populate. It is up to the caller to ensure this array can hold at least nb_results elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<p>/see lr1110_wifi_read_basic_complete_results, lr1110_wifi_read_basic_mac_type_channel_results </p>

</div>
</div>
<a id="ab8ceb1521a3c898827517435b621c2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ceb1521a3c898827517435b621c2a7">&#9670;&nbsp;</a></span>lr1110_wifi_reset_cumulative_timing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_reset_cumulative_timing </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the internal counters of cumulative timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="a7941b72b58a2dae76fecbe3246cb07c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7941b72b58a2dae76fecbe3246cb07c4">&#9670;&nbsp;</a></span>lr1110_wifi_read_cumulative_timing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_cumulative_timing </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#a1cf72df541b0429ac38c286e59077dd5">lr1110_wifi_cumulative_timings_t</a> *&#160;</td>
          <td class="paramname"><em>timing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the internal counters of cumulative timing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timing</td><td>A pointer to the cumulative timing structure to populate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="aed08daaa085ca5ee6fccac5e559d99f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed08daaa085ca5ee6fccac5e559d99f5">&#9670;&nbsp;</a></span>lr1110_wifi_get_nb_country_code_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_get_nb_country_code_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>nb_country_code_results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of country code search results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_country_code_results</td><td>Number of country results to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="a4cfcca113b09db1f26d6180ab0baf06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfcca113b09db1f26d6180ab0baf06b">&#9670;&nbsp;</a></span>lr1110_wifi_read_country_code_results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_country_code_results </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>start_result_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>nb_country_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#ac2d739e442552f15bf6ebd121894ae6a">lr1110_wifi_country_code_t</a> *&#160;</td>
          <td class="paramname"><em>country_code_results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read country code results. </p>
<p>The total number of country code results to read is obtained from a previous call to lr1110_wifi_get_nb_country_code_results</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_result_index</td><td>The result index to start reading results from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_country_results</td><td>Number of country code results to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">country_code_results</td><td>An array of lr1110_wifi_country_code_t to be filled. It is up to the application to ensure this array is big enough to hold nb_country_results elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#aed08daaa085ca5ee6fccac5e559d99f5" title="Get size of country code search results.">lr1110_wifi_get_nb_country_code_results</a>, <a class="el" href="lr1110__wifi_8h.html#a3a86b1bca06ce60e05f30c549e4aa004" title="Start a Wi-Fi passive scan for country codes extraction.">lr1110_wifi_search_country_code</a> </dd></dl>

</div>
</div>
<a id="a0830785641ca030a7ea55093bff70605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0830785641ca030a7ea55093bff70605">&#9670;&nbsp;</a></span>lr1110_wifi_cfg_timestamp_ap_phone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_cfg_timestamp_ap_phone </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timestamp_in_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the timestamp used to discriminate mobile access points from gateways. </p>
<p>This filtering is based on the hypothesis that mobile access points have timestamp shorter than gateways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_in_s</td><td>Timestamp value in second</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="a1a7521fc045807639176f8a329116bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7521fc045807639176f8a329116bb4">&#9670;&nbsp;</a></span>lr1110_wifi_read_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__types_8h.html#a8bbdb156822c2fd3e56fefb6928d3a57">lr1110_status_t</a> lr1110_wifi_read_version </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#acc25030e0dfd97c4eb3280a80713d69c">lr1110_wifi_version_t</a> *&#160;</td>
          <td class="paramname"><em>wifi_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal wifi firmware version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Chip implementation context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wifi_version</td><td>The wifi version structure populated with version numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>

</div>
</div>
<a id="ad276a2e5ad038fd6eadfe99211f60040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad276a2e5ad038fd6eadfe99211f60040">&#9670;&nbsp;</a></span>lr1110_wifi_parse_channel_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lr1110_wifi_parse_channel_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a55e3c183efeb5aa35eadfff058f3f5e1">lr1110_wifi_channel_info_byte_t</a>&#160;</td>
          <td class="paramname"><em>channel_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#a17c9dcc3e3e493f2a6ef4d877694955e">lr1110_wifi_channel_t</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>rssi_validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#a52372df6137d900b25c37f6ba2707dbe">lr1110_wifi_mac_origin_t</a> *&#160;</td>
          <td class="paramname"><em>mac_origin_estimation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retreive channel information from channel info byte. </p>
<p>This method is to be called with on the WiFi channel info byte of a scan result.</p>
<p>As the WiFi passive scan allows to get Access Point MAC address from Packet WiFi frames, it is possible that the frame does not comes from the Access Point, but from a device. In that case, the RSSI reported by LR1110 is the one of the frame received from the device and not from the Access Point. The rssi_validity flag allows to detect that case.</p>
<p>It is possible for an Access Point to be a mobile AP, which is of low interest for location purpose. The LR1110 tries to detect mobile AP based on Access Point up time and set the flag mac_origin_estimation accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_info</td><td>The channel info byte to retrieve channel information from. It is obtained from WiFi passive scan result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">channel</td><td>The channel of the scanned mac address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rssi_validity</td><td>The validity of the scanned MAC address </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_origin_estimation</td><td>Indicates the estimation of MAC address origin by LR1110</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#afaa8b1b61c77ebfade5287f79cb0fb4c" title="Read basic complete results.">lr1110_wifi_read_basic_complete_results</a>, <a class="el" href="lr1110__wifi_8h.html#af3549195b4839a4ba91ea6cbfd15ae64" title="Read basic MAC, Wi-Fi type and channel results.">lr1110_wifi_read_basic_mac_type_channel_results</a>, <a class="el" href="lr1110__wifi_8h.html#a0830785641ca030a7ea55093bff70605" title="Configure the timestamp used to discriminate mobile access points from gateways.">lr1110_wifi_cfg_timestamp_ap_phone</a> </dd></dl>

</div>
</div>
<a id="a240bebced5794ce6dd84c017b287d56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240bebced5794ce6dd84c017b287d56e">&#9670;&nbsp;</a></span>lr1110_wifi_extract_channel_from_info_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__wifi__types_8h.html#a17c9dcc3e3e493f2a6ef4d877694955e">lr1110_wifi_channel_t</a> lr1110_wifi_extract_channel_from_info_byte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a55e3c183efeb5aa35eadfff058f3f5e1">lr1110_wifi_channel_info_byte_t</a>&#160;</td>
          <td class="paramname"><em>channel_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to retrieve channel from channel info byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_info</td><td>The chanel info byte from passive scan result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The channel of scanned MAC address</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#ad276a2e5ad038fd6eadfe99211f60040" title="Retreive channel information from channel info byte.">lr1110_wifi_parse_channel_info</a> </dd></dl>

</div>
</div>
<a id="a0fe1fb53c0befea5ab7b46cfa22ad9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe1fb53c0befea5ab7b46cfa22ad9bb">&#9670;&nbsp;</a></span>lr1110_wifi_parse_frame_type_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lr1110_wifi_parse_frame_type_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#ac77a5ef55c00bf569d351b1f15c5751a">lr1110_wifi_frame_type_info_byte_t</a>&#160;</td>
          <td class="paramname"><em>frame_type_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#ae25235b3295d30fb4ff8919621d9d2c1">lr1110_wifi_frame_type_t</a> *&#160;</td>
          <td class="paramname"><em>frame_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#ade9a701f69fbd51944d656ff077d9a31">lr1110_wifi_frame_sub_type_t</a> *&#160;</td>
          <td class="paramname"><em>frame_sub_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>to_ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>from_ds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the Frame Type, Frame Subtype, To/From DS fields from a frame info byte. </p>
<p>This method is intended to be called on the channel info byte of a passive scan result structure.</p>
<p>The from_ds/to_ds (Distribution Station) fields have the following meaning:</p>
<table class="doxtable">
<tr>
<th>to_ds value </th><th>from_ds value </th><th>Meaning  </th></tr>
<tr>
<td>False </td><td>False </td><td>Frame was between two Stations  </td></tr>
<tr>
<td>True </td><td>False </td><td>Frame was from Station to Access Point  </td></tr>
<tr>
<td>False </td><td>True </td><td>Frame was sent from Access Point or Distribution Stations  </td></tr>
<tr>
<td>True </td><td>True </td><td>Mesh network only, frame was between Stations  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_type_info</td><td>The frame info byte from passive scan result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frame_type</td><td>The Frame Type of the received frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">frame_sub_type</td><td>The Frame SubType of the frame received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to_ds</td><td>to_ds field of the frame received </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">from_ds</td><td>from_ds field of the frame received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4ea70c760033e0dd8d89706961d6ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ea70c760033e0dd8d89706961d6ef5">&#9670;&nbsp;</a></span>lr1110_wifi_parse_data_rate_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lr1110_wifi_parse_data_rate_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a82d577debca5410696b4f512da982462">lr1110_wifi_datarate_info_byte_t</a>&#160;</td>
          <td class="paramname"><em>data_rate_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#a14d9ec9ba9116e22b5da4f8af7d1d9a5">lr1110_wifi_signal_type_result_t</a> *&#160;</td>
          <td class="paramname"><em>wifi_signal_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lr1110__wifi__types_8h.html#a3a34adce775e61290a566006f51d6801">lr1110_wifi_datarate_t</a> *&#160;</td>
          <td class="paramname"><em>wifi_data_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the data rate information from data rate info byte. </p>
<p>This method is intended to be called on a data rate info byte of a passive scan result structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_rate_info</td><td>The data rate info byte from a passive scan result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wifi_signal_type</td><td>The wifi signal type of the scanned frame </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wifi_data_rate</td><td>The data rate of the scanned frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe6dae23951bad6722ca4fe3cd9317a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe6dae23951bad6722ca4fe3cd9317a">&#9670;&nbsp;</a></span>lr1110_wifi_get_nb_results_max_per_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t lr1110_wifi_get_nb_results_max_per_chunk </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximal number of results to read per SPI communication. </p>
<p>This function <b>DOES NOT</b> communicates with the LR1110. It returns the driver maximal number of Wi-Fi results it can retrieve per SPI communication.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It is a driver limitation, not a LR1110 limitation, that avoid allocating temporary buffers of size too big when reading Wi-Fi passive scan results.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="lr1110__wifi_8h.html#ada49120c783c278ea384029687de12d0" title="The number of results max to fetch per SPI communication with the chip.">LR1110_WIFI_N_RESULTS_MAX_PER_CHUNK</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The maximal number of results to fetch per SPI calls </dd></dl>

</div>
</div>
<a id="a4621fe36d6aefdcb5bd80c8de55dbc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4621fe36d6aefdcb5bd80c8de55dbc1c">&#9670;&nbsp;</a></span>lr1110_wifi_extract_signal_type_from_data_rate_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="lr1110__wifi__types_8h.html#a14d9ec9ba9116e22b5da4f8af7d1d9a5">lr1110_wifi_signal_type_result_t</a> lr1110_wifi_extract_signal_type_from_data_rate_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="lr1110__wifi__types_8h.html#a82d577debca5410696b4f512da982462">lr1110_wifi_datarate_info_byte_t</a>&#160;</td>
          <td class="paramname"><em>data_rate_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to retrieve the signal type from data rate info byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_rate_info</td><td>The data rate info byte from a passive scan result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Signal Type of the scanned frame </dd></dl>

</div>
</div>
<a id="ae9c7589b9d44acd564cb14919f55ca1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c7589b9d44acd564cb14919f55ca1c">&#9670;&nbsp;</a></span>lr1110_wifi_is_well_formed_utf8_byte_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lr1110_wifi_is_well_formed_utf8_byte_sequence </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to check if a buffer is a well-formed UTF-8 byte sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer holding the bytes to be analyzed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes in the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the check </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="astructlr1110__wifi__basic__mac__type__channel__result__s_html"><div class="ttname"><a href="structlr1110__wifi__basic__mac__type__channel__result__s.html">lr1110_wifi_basic_mac_type_channel_result_s</a></div><div class="ttdoc">Basic MAC, type, channel result structure.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi_types.h:320</div></div>
<div class="ttc" id="astructlr1110__wifi__extended__full__result__t_html"><div class="ttname"><a href="structlr1110__wifi__extended__full__result__t.html">lr1110_wifi_extended_full_result_t</a></div><div class="ttdoc">Extended full result structure.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi_types.h:339</div></div>
<div class="ttc" id="alr1110__wifi_8c_html_a81b8b6b2947c8a26554cffc9b26c6369"><div class="ttname"><a href="lr1110__wifi_8c.html#a81b8b6b2947c8a26554cffc9b26c6369">lr1110_wifi_read_extended_full_results</a></div><div class="ttdeci">lr1110_status_t lr1110_wifi_read_extended_full_results(const void *radio, const uint8_t start_result_index, const uint8_t nb_results, lr1110_wifi_extended_full_result_t *results)</div><div class="ttdoc">Read extended complete results.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi.c:366</div></div>
<div class="ttc" id="astructlr1110__wifi__basic__complete__result__s_html"><div class="ttname"><a href="structlr1110__wifi__basic__complete__result__s.html">lr1110_wifi_basic_complete_result_s</a></div><div class="ttdoc">Basic complete result structure.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi_types.h:305</div></div>
<div class="ttc" id="alr1110__wifi_8c_html_af3549195b4839a4ba91ea6cbfd15ae64"><div class="ttname"><a href="lr1110__wifi_8c.html#af3549195b4839a4ba91ea6cbfd15ae64">lr1110_wifi_read_basic_mac_type_channel_results</a></div><div class="ttdeci">lr1110_status_t lr1110_wifi_read_basic_mac_type_channel_results(const void *context, const uint8_t start_result_index, const uint8_t nb_results, lr1110_wifi_basic_mac_type_channel_result_t *results)</div><div class="ttdoc">Read basic MAC, Wi-Fi type and channel results.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi.c:350</div></div>
<div class="ttc" id="alr1110__wifi_8c_html_aceacb572995705d93d049e1f6e058f0e"><div class="ttname"><a href="lr1110__wifi_8c.html#aceacb572995705d93d049e1f6e058f0e">lr1110_wifi_get_nb_results</a></div><div class="ttdeci">lr1110_status_t lr1110_wifi_get_nb_results(const void *context, uint8_t *nb_results)</div><div class="ttdoc">Returns the number of results currently available in LR1110.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi.c:324</div></div>
<div class="ttc" id="alr1110__wifi_8c_html_afaa8b1b61c77ebfade5287f79cb0fb4c"><div class="ttname"><a href="lr1110__wifi_8c.html#afaa8b1b61c77ebfade5287f79cb0fb4c">lr1110_wifi_read_basic_complete_results</a></div><div class="ttdeci">lr1110_status_t lr1110_wifi_read_basic_complete_results(const void *context, const uint8_t start_result_index, const uint8_t nb_results, lr1110_wifi_basic_complete_result_t *results)</div><div class="ttdoc">Read basic complete results.</div><div class="ttdef"><b>Definition:</b> lr1110_wifi.c:335</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
